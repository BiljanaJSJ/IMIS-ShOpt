
R version 3.5.0 (2018-04-23) -- "Joy in Playing"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> ########################################################################################
> #This file runs both IMIS-ShOpt and IMIS-Opt with the same settings and write files with results
> ########################################################################################
> rm(list = ls(all = TRUE))
> 
> source("Two-stage-FhN-just-c-with-prior.R")                         # 2-stage functions
> source("IMIS.opt.colloc.proc-3optimizers.general-no-touchups.R")    # General IMIS 3 optimizers function 
> source("fhn-model-set-up-x0proc-just-c.R")                          # likelihood etc...
> source("FhN-model-set-up-as-ode-x0proc-thetalik-justc.R")		        # basic FhN functions
> #source('AnimationRuns.R')
> 
> # include an ode solver package
> library(deSolve)
> library(mvtnorm)
> library(coda)
> library(numDeriv)
> library(fda)
Loading required package: splines
Loading required package: Matrix

Attaching package: ‘fda’

The following object is masked from ‘package:graphics’:

    matplot

> library(CollocInfer)
> source("makeSSElik.R")
> source("makeSSEprocFHN.R")
> 
> 
> library(doParallel)
Loading required package: foreach
Loading required package: iterators
Loading required package: parallel
> 
> fhn<- make.FHN()
> 
> #make some fake data
> times = seq(0,20,0.2) 
> print("Note that the parameter labelled 'sd' is actually a variance.  will fix this eventually")
[1] "Note that the parameter labelled 'sd' is actually a variance.  will fix this eventually"
> x0	= c(-1,1) 
> names(x0) = c("V","R")
> pars=c(3)
> parnames =names(pars)=c("c")
> 
> y	= lsoda(x0,times,fhn$fn.ode,pars) 
> 
> y	= y[,2:3] 
> data = y + matrix(rnorm(dim(y)[1]*2,0,sqrt(.05^2)),length(times),2)
> 
> 
> lambda=1000
> 
> knots = knots = seq(0,20,1) 
> 
> norder= 3									# order of the b-spline basis
> nbasis = length(knots) +norder -2           # number of basis functions
> range = c(0,max(times))						# time span of the observations
> bbasis = create.bspline.basis(range=range, nbasis=nbasis, norder=norder, breaks=knots)
> fd.data = array(data,c(nrow(data),1,ncol(data)))
> DEfd = Data2fd(y=fd.data,argvals=times,basisobj=bbasis,fdnames = list(NULL,NULL, colnames(data)))
> if(!exists("DEfd",where=1)){# then the data2fd line failed - this can occur when there are unobserved variables
+   data.temp=array(0,dim(fd.data))
+   data.temp[,,apply(is.na(fd.data),3,sum)<(dim(fd.data)[1]-2)]    =fd.data[,,apply(is.na(fd.data),3,sum)<(dim(fd.data)[1]-2)]
+   DEfd.temp = Data2fd(data.temp,times,bbasis,fdnames = list(NULL,NULL, colnames(data)))	
+ }				
> coefs = DEfd$coefs
> colnames(coefs) = colnames(data)
> 
> #
> 
> lik=make.SSElik.with.prior.and.sd()
> lik$bvals = eval.basis(times,bbasis)
> #lik$bvals[1,] = 0###########because I need to put all of the dlik/dc(1) into dlik/dp for X(0)
> lik$more	= make.id() 
> lik$more$weights = array(1,dim(data)) 
> lik$more$bvals  = eval.basis(times,bbasis,0)     ######## needed only if x0 is a parameter
> lik$more$dbvals = eval.basis(times,bbasis,1)    ######## needed only if x0 is a parameter
> lik$x0index = c(5,6)  # index for the initial conditions
> proc=make.SSEproc.FHN()
> proc$bvals=lik$bvals
> qpts =knots
> qwts = rep(diff(range(times))/length(knots),length(knots))
> qwtsL = qwts %*% t(lambda)
> proc$more = fhn 
> proc$more$weightsNoL = qwts 
> proc$more$lambda = lambda 
> proc$more$weights = qwtsL 
> 
> proc$more$qpts	= qpts 
> proc$more$parnames	= 'c'
> proc$more$names	= c("V","R")
> proc$bvals = list(bvals = eval.basis(proc$more$qpts,bbasis,0), dbvals = eval.basis(proc$more$qpts,bbasis,1))
> print("Note that the lambda value ignored since proc is supplied")
[1] "Note that the lambda value ignored since proc is supplied"
> 
> # end of FDA set up stuff
> # smoothing based optimizer control options
> 
> control=list()
> control$trace=0
> control$iter.max=1000
> control$eval.max=1e3
> control$rel.tol=1e-8
> control.in=control
> control.in$rel.tol = 1e-12
> control.in$iter.max = 1000
> control.out=control
> control.out$trace=1
> 
> 
> colnames(coefs) = names(x0)
> 
> 
> 
> #spars = c(.2,.2,14,1,-.5,.5)          # Perturbed parameters  Note that the first two should stay fixed since we are dealing with a one dimensional 
> #system.  The third parameter is the one to manipulate
> #names(spars)=c("c")
> 
> B=1000
> B.re=10000
> number_k=150
> D=4
> parnames = names(pars)
> datamatrix=data
> plots=1
> likelihood.w.fit=NULL
> ncoefs=0
> 
> 
> other = list()
> other$coefs        = coefs    
> other$lik          = lik         
> other$proc         = proc       
> proc$more$parnames = names(pars) 
> other$control.in   = control.in  
> other$control.out  = control.out 
> other$ncoefs       = ncoefs      
> 
> optim.fun1 = ident
> optim.fun2 = smoother.opt
> optim.fun3 = twostage.optim.fhn.justc
> 
> cl <- makeCluster(4)
> registerDoParallel(cl)
> clusterCall(cl,function(x) {library(deSolve);library(CollocInfer);library(numDeriv);library(lokern)})
[[1]]
 [1] "lokern"      "numDeriv"    "CollocInfer" "fda"         "Matrix"     
 [6] "splines"     "deSolve"     "stats"       "graphics"    "grDevices"  
[11] "utils"       "datasets"    "methods"     "base"       

[[2]]
 [1] "lokern"      "numDeriv"    "CollocInfer" "fda"         "Matrix"     
 [6] "splines"     "deSolve"     "stats"       "graphics"    "grDevices"  
[11] "utils"       "datasets"    "methods"     "base"       

[[3]]
 [1] "lokern"      "numDeriv"    "CollocInfer" "fda"         "Matrix"     
 [6] "splines"     "deSolve"     "stats"       "graphics"    "grDevices"  
[11] "utils"       "datasets"    "methods"     "base"       

[[4]]
 [1] "lokern"      "numDeriv"    "CollocInfer" "fda"         "Matrix"     
 [6] "splines"     "deSolve"     "stats"       "graphics"    "grDevices"  
[11] "utils"       "datasets"    "methods"     "base"       

> clusterExport(cl,varlist=list('IMIS.opt.colloc.3optimizers.general.no.touch.ups','d2negnormdp2',"make.fhn","%dopar%","foreach",'make.SSEproc.FHN',"neglogprior","prior","likelihood",'times',"dnegnormdp",'make.SSElik',"dneglogpriordpar","lokerns","ksLqudratic",'simex.fun.justc','neq','der.fhn.justc','jac.fhn.justc','d2neglogpriordpar2'))
> clusterExport(cl,varlist=ls())
> 
> # t1=proc.time()[1]
> # ##run the IMIS-ShOpt algorithm
> # output<- IMIS.opt.colloc.3optimizers.general.no.touch.ups(B, B.re, number_k, D,parnames = c("c"),data=data, plots=0, ncoefs=ncoefs, optim.fun1, optim.fun2, optim.fun3,other)
> # ##save the results
> # save(output,file='FhN_1Param_IMIS_Shopt_D30.RData')
> # (t=proc.time()[1]-t1)/60
> # proc.time()
> # 
> # 
> # #run the IMIS-Opt
> # t1=proc.time()[1]
> # source('IMIS.R')
> # output_IMIS_opt<- IMIS(B, B.re, number_k, D=3,logging=TRUE,data)
> # #save results
> # save(output_IMIS_opt,file='FhN_1Param_IMIS_Opt_D3.RData')
> # (t=proc.time()[1]-t1)/60
> # stopCluster(cl)
> # 
> # proc.time()
> 
> 
> 
> 
> 
> 
> #exclude NLS optimizer
> 
> t1=proc.time()[1]
> ##run the IMIS-ShOpt algorithm
> output<- IMIS.opt.colloc.3optimizers.general.no.touch.ups(B, B.re, number_k,D, runIndex=2:3, parnames = c("c"),data=data, plots=0, ncoefs=ncoefs, optim.fun1, optim.fun2, optim.fun3,other)
[1] "herek"
[1] 1
[1] "10000 likelihoods are evaluated in 0.88 minutes"
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]   1.000  -9.210 128.250   0.023  57.683
[1] "Here 1"
[1] "herei"
[1] 1
[1] "i= 1"
[1] "optimization starting from a value of  11.9737705315636"
[1] "herei"
[1] 2
[1] "i= 2"
[1] "optimization starting from a value of  12.3017127250789"
[1] "herei"
[1] 3
[1] "i= 3"
[1] "optimization starting from a value of  13.426176081412"
[1] "Here 3"
[1] "here it is"
[1] "herek"
[1] 2
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    2.000   -9.680 4866.877    0.000 5999.893
[1] "k>1, k= 2"
[1] "here it is"
[1] "herek"
[1] 3
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    3.000   -9.741 4992.551    0.000 6240.207
[1] "k>1, k= 3"
[1] "here it is"
[1] "herek"
[1] 4
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    4.000   -9.798 5256.391    0.000 6689.335
[1] "k>1, k= 4"
[1] "here it is"
[1] "herek"
[1] 5
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    5.000   -9.852 5524.524    0.000 7221.369
[1] "k>1, k= 5"
[1] "here it is"
[1] "herek"
[1] 6
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    6.000   -9.903 5793.767    0.000 7851.835
[1] "k>1, k= 6"
[1] "here it is"
[1] "herek"
[1] 7
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    7.000   -9.952 6091.944    0.000 8741.379
[1] "k>1, k= 7"
[1] "here it is"
[1] "herek"
[1] 8
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]    8.000   -9.999 6291.527    0.000 9372.875
[1] "k>1, k= 8"
[1] "here it is"
[1] "herek"
[1] 9
[1] "Stage   MargLike   UniquePoint   MaxWeight   ESS"
[1]     9.000   -10.043  6593.098     0.000 10702.523
[1] "k>1, k= 9"
[1] "here it is"
Warning messages:
1: In e$fun(obj, substitute(ex), parent.frame(), e$data) :
  already exporting variable(s): neglogpriorx0
2: In runIndex == 1:3 :
  longer object length is not a multiple of shorter object length
3: In e$fun(obj, substitute(ex), parent.frame(), e$data) :
  already exporting variable(s): neglogpriorx0
4: In runIndex == 1:3 :
  longer object length is not a multiple of shorter object length
5: In e$fun(obj, substitute(ex), parent.frame(), e$data) :
  already exporting variable(s): neglogpriorx0
6: In runIndex == 1:3 :
  longer object length is not a multiple of shorter object length
>                                                         
> ##save the results
> save(output,file='FhN_1Param_IMIS_Shopt_D30_2_3.RData')
> (t=proc.time()[1]-t1)/60
user.self 
   0.5281 
> proc.time()
   user  system elapsed 
 34.469   3.414 367.720 
> 
> 
> output=get(load('FhN_1Param_IMIS_Shopt_D30_2_3.RData'))
> output$center
 [1] 3.000464 3.000464 3.000462 3.000464 3.000464 3.000464 2.962773 3.004325
 [9] 2.999783 3.008995 2.996155 3.015011 2.992130 2.987371
> 
> 
> 
> proc.time()
   user  system elapsed 
 34.475   3.414 367.727 
